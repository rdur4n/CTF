/**
 * Autogenerated by Thrift Compiler (0.20.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ThriftTest_H
#define ThriftTest_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "ThriftTest_types.h"

namespace thrift { namespace test {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class ThriftTestIf {
 public:
  virtual ~ThriftTestIf() {}

  /**
   * Prints "testVoid()" and returns nothing.
   */
  virtual void testVoid() = 0;

  /**
   * Prints 'testString("%s")' with thing as '%s'
   * @param string thing - the string to print
   * @return string - returns the string 'thing'
   * 
   * @param thing
   */
  virtual void testString(std::string& _return, const std::string& thing) = 0;

  /**
   * Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
   * @param bool  thing - the bool data to print
   * @return bool  - returns the bool 'thing'
   * 
   * @param thing
   */
  virtual bool testBool(const bool thing) = 0;

  /**
   * Prints 'testByte("%d")' with thing as '%d'
   * The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
   * @param byte thing - the i8/byte to print
   * @return i8 - returns the i8/byte 'thing'
   * 
   * @param thing
   */
  virtual int8_t testByte(const int8_t thing) = 0;

  /**
   * Prints 'testI32("%d")' with thing as '%d'
   * @param i32 thing - the i32 to print
   * @return i32 - returns the i32 'thing'
   * 
   * @param thing
   */
  virtual int32_t testI32(const int32_t thing) = 0;

  /**
   * Prints 'testI64("%d")' with thing as '%d'
   * @param i64 thing - the i64 to print
   * @return i64 - returns the i64 'thing'
   * 
   * @param thing
   */
  virtual int64_t testI64(const int64_t thing) = 0;

  /**
   * Prints 'testDouble("%f")' with thing as '%f'
   * @param double thing - the double to print
   * @return double - returns the double 'thing'
   * 
   * @param thing
   */
  virtual double testDouble(const double thing) = 0;

  /**
   * Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
   * @param binary  thing - the binary data to print
   * @return binary  - returns the binary 'thing'
   * 
   * @param thing
   */
  virtual void testBinary(std::string& _return, const std::string& thing) = 0;

  /**
   * Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
   * @param Xtruct thing - the Xtruct to print
   * @return Xtruct - returns the Xtruct 'thing'
   * 
   * @param thing
   */
  virtual void testStruct(Xtruct& _return, const Xtruct& thing) = 0;

  /**
   * Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
   * @param Xtruct2 thing - the Xtruct2 to print
   * @return Xtruct2 - returns the Xtruct2 'thing'
   * 
   * @param thing
   */
  virtual void testNest(Xtruct2& _return, const Xtruct2& thing) = 0;

  /**
   * Prints 'testMap("{%s")' where thing has been formatted into a string of 'key => value' pairs
   *  separated by commas and new lines
   * @param map<i32,i32> thing - the map<i32,i32> to print
   * @return map<i32,i32> - returns the map<i32,i32> 'thing'
   * 
   * @param thing
   */
  virtual void testMap(std::map<int32_t, int32_t> & _return, const std::map<int32_t, int32_t> & thing) = 0;

  /**
   * Prints 'testStringMap("{%s}")' where thing has been formatted into a string of 'key => value' pairs
   *  separated by commas and new lines
   * @param map<string,string> thing - the map<string,string> to print
   * @return map<string,string> - returns the map<string,string> 'thing'
   * 
   * @param thing
   */
  virtual void testStringMap(std::map<std::string, std::string> & _return, const std::map<std::string, std::string> & thing) = 0;

  /**
   * Prints 'testSet("{%s}")' where thing has been formatted into a string of values
   *  separated by commas and new lines
   * @param set<i32> thing - the set<i32> to print
   * @return set<i32> - returns the set<i32> 'thing'
   * 
   * @param thing
   */
  virtual void testSet(std::set<int32_t> & _return, const std::set<int32_t> & thing) = 0;

  /**
   * Prints 'testList("{%s}")' where thing has been formatted into a string of values
   *  separated by commas and new lines
   * @param list<i32> thing - the list<i32> to print
   * @return list<i32> - returns the list<i32> 'thing'
   * 
   * @param thing
   */
  virtual void testList(std::vector<int32_t> & _return, const std::vector<int32_t> & thing) = 0;

  /**
   * Prints 'testEnum("%d")' where thing has been formatted into its numeric value
   * @param Numberz thing - the Numberz to print
   * @return Numberz - returns the Numberz 'thing'
   * 
   * @param thing
   */
  virtual Numberz::type testEnum(const Numberz::type thing) = 0;

  /**
   * Prints 'testTypedef("%d")' with thing as '%d'
   * @param UserId thing - the UserId to print
   * @return UserId - returns the UserId 'thing'
   * 
   * @param thing
   */
  virtual UserId testTypedef(const UserId thing) = 0;

  /**
   * Prints 'testMapMap("%d")' with hello as '%d'
   * @param i32 hello - the i32 to print
   * @return map<i32,map<i32,i32>> - returns a dictionary with these values:
   *   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
   * 
   * @param hello
   */
  virtual void testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t hello) = 0;

  /**
   * So you think you've got this all worked out, eh?
   * 
   * Creates a map with these values and prints it out:
   *   { 1 => { 2 => argument,
   *            3 => argument,
   *          },
   *     2 => { 6 => <empty Insanity struct>, },
   *   }
   * @return map<UserId, map<Numberz,Insanity>> - a map with the above values
   * 
   * @param argument
   */
  virtual void testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const Insanity& argument) = 0;

  /**
   * Prints 'testMulti()'
   * @param i8 arg0 -
   * @param i32 arg1 -
   * @param i64 arg2 -
   * @param map<i16, string> arg3 -
   * @param Numberz arg4 -
   * @param UserId arg5 -
   * @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
   *    and i64_thing = arg2
   * 
   * @param arg0
   * @param arg1
   * @param arg2
   * @param arg3
   * @param arg4
   * @param arg5
   */
  virtual void testMulti(Xtruct& _return, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5) = 0;

  /**
   * Print 'testException(%s)' with arg as '%s'
   * @param string arg - a string indication what type of exception to throw
   * if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
   * else if arg == "TException" throw TException
   * else do not throw anything
   * 
   * @param arg
   */
  virtual void testException(const std::string& arg) = 0;

  /**
   * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
   * @param string arg - a string indicating what type of exception to throw
   * if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
   * else if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
   * else do not throw anything
   * @return Xtruct - an Xtruct with string_thing = arg1
   * 
   * @param arg0
   * @param arg1
   */
  virtual void testMultiException(Xtruct& _return, const std::string& arg0, const std::string& arg1) = 0;

  /**
   * Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
   * sleep 'secondsToSleep'
   * Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
   * @param i32 secondsToSleep - the number of seconds to sleep
   * 
   * @param secondsToSleep
   */
  virtual void testOneway(const int32_t secondsToSleep) = 0;
};

class ThriftTestIfFactory {
 public:
  typedef ThriftTestIf Handler;

  virtual ~ThriftTestIfFactory() {}

  virtual ThriftTestIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ThriftTestIf* /* handler */) = 0;
  };

class ThriftTestIfSingletonFactory : virtual public ThriftTestIfFactory {
 public:
  ThriftTestIfSingletonFactory(const ::std::shared_ptr<ThriftTestIf>& iface) : iface_(iface) {}
  virtual ~ThriftTestIfSingletonFactory() {}

  virtual ThriftTestIf* getHandler(const ::apache::thrift::TConnectionInfo&) override {
    return iface_.get();
  }
  virtual void releaseHandler(ThriftTestIf* /* handler */) override {}

 protected:
  ::std::shared_ptr<ThriftTestIf> iface_;
};

class ThriftTestNull : virtual public ThriftTestIf {
 public:
  virtual ~ThriftTestNull() {}
  void testVoid() override {
    return;
  }
  void testString(std::string& /* _return */, const std::string& /* thing */) override {
    return;
  }
  bool testBool(const bool /* thing */) override {
    bool _return = false;
    return _return;
  }
  int8_t testByte(const int8_t /* thing */) override {
    int8_t _return = 0;
    return _return;
  }
  int32_t testI32(const int32_t /* thing */) override {
    int32_t _return = 0;
    return _return;
  }
  int64_t testI64(const int64_t /* thing */) override {
    int64_t _return = 0;
    return _return;
  }
  double testDouble(const double /* thing */) override {
    double _return = 0.0;
    return _return;
  }
  void testBinary(std::string& /* _return */, const std::string& /* thing */) override {
    return;
  }
  void testStruct(Xtruct& /* _return */, const Xtruct& /* thing */) override {
    return;
  }
  void testNest(Xtruct2& /* _return */, const Xtruct2& /* thing */) override {
    return;
  }
  void testMap(std::map<int32_t, int32_t> & /* _return */, const std::map<int32_t, int32_t> & /* thing */) override {
    return;
  }
  void testStringMap(std::map<std::string, std::string> & /* _return */, const std::map<std::string, std::string> & /* thing */) override {
    return;
  }
  void testSet(std::set<int32_t> & /* _return */, const std::set<int32_t> & /* thing */) override {
    return;
  }
  void testList(std::vector<int32_t> & /* _return */, const std::vector<int32_t> & /* thing */) override {
    return;
  }
  Numberz::type testEnum(const Numberz::type /* thing */) override {
    Numberz::type _return = static_cast<Numberz::type>(0);
    return _return;
  }
  UserId testTypedef(const UserId /* thing */) override {
    UserId _return = 0;
    return _return;
  }
  void testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & /* _return */, const int32_t /* hello */) override {
    return;
  }
  void testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & /* _return */, const Insanity& /* argument */) override {
    return;
  }
  void testMulti(Xtruct& /* _return */, const int8_t /* arg0 */, const int32_t /* arg1 */, const int64_t /* arg2 */, const std::map<int16_t, std::string> & /* arg3 */, const Numberz::type /* arg4 */, const UserId /* arg5 */) override {
    return;
  }
  void testException(const std::string& /* arg */) override {
    return;
  }
  void testMultiException(Xtruct& /* _return */, const std::string& /* arg0 */, const std::string& /* arg1 */) override {
    return;
  }
  void testOneway(const int32_t /* secondsToSleep */) override {
    return;
  }
};


class ThriftTest_testVoid_args {
 public:

  ThriftTest_testVoid_args(const ThriftTest_testVoid_args&) noexcept;
  ThriftTest_testVoid_args& operator=(const ThriftTest_testVoid_args&) noexcept;
  ThriftTest_testVoid_args() noexcept {
  }

  virtual ~ThriftTest_testVoid_args() noexcept;

  bool operator == (const ThriftTest_testVoid_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ThriftTest_testVoid_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testVoid_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testVoid_pargs {
 public:


  virtual ~ThriftTest_testVoid_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testVoid_result {
 public:

  ThriftTest_testVoid_result(const ThriftTest_testVoid_result&) noexcept;
  ThriftTest_testVoid_result& operator=(const ThriftTest_testVoid_result&) noexcept;
  ThriftTest_testVoid_result() noexcept {
  }

  virtual ~ThriftTest_testVoid_result() noexcept;

  bool operator == (const ThriftTest_testVoid_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ThriftTest_testVoid_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testVoid_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testVoid_presult {
 public:


  virtual ~ThriftTest_testVoid_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testString_args__isset {
  _ThriftTest_testString_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testString_args__isset;

class ThriftTest_testString_args {
 public:

  ThriftTest_testString_args(const ThriftTest_testString_args&);
  ThriftTest_testString_args& operator=(const ThriftTest_testString_args&);
  ThriftTest_testString_args() noexcept
                             : thing() {
  }

  virtual ~ThriftTest_testString_args() noexcept;
  std::string thing;

  _ThriftTest_testString_args__isset __isset;

  void __set_thing(const std::string& val);

  bool operator == (const ThriftTest_testString_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testString_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testString_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testString_pargs {
 public:


  virtual ~ThriftTest_testString_pargs() noexcept;
  const std::string* thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testString_result__isset {
  _ThriftTest_testString_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testString_result__isset;

class ThriftTest_testString_result {
 public:

  ThriftTest_testString_result(const ThriftTest_testString_result&);
  ThriftTest_testString_result& operator=(const ThriftTest_testString_result&);
  ThriftTest_testString_result() noexcept
                               : success() {
  }

  virtual ~ThriftTest_testString_result() noexcept;
  std::string success;

  _ThriftTest_testString_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const ThriftTest_testString_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testString_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testString_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testString_presult__isset {
  _ThriftTest_testString_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testString_presult__isset;

class ThriftTest_testString_presult {
 public:


  virtual ~ThriftTest_testString_presult() noexcept;
  std::string* success;

  _ThriftTest_testString_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testBool_args__isset {
  _ThriftTest_testBool_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testBool_args__isset;

class ThriftTest_testBool_args {
 public:

  ThriftTest_testBool_args(const ThriftTest_testBool_args&) noexcept;
  ThriftTest_testBool_args& operator=(const ThriftTest_testBool_args&) noexcept;
  ThriftTest_testBool_args() noexcept
                           : thing(0) {
  }

  virtual ~ThriftTest_testBool_args() noexcept;
  bool thing;

  _ThriftTest_testBool_args__isset __isset;

  void __set_thing(const bool val);

  bool operator == (const ThriftTest_testBool_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testBool_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testBool_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testBool_pargs {
 public:


  virtual ~ThriftTest_testBool_pargs() noexcept;
  const bool* thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testBool_result__isset {
  _ThriftTest_testBool_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testBool_result__isset;

class ThriftTest_testBool_result {
 public:

  ThriftTest_testBool_result(const ThriftTest_testBool_result&) noexcept;
  ThriftTest_testBool_result& operator=(const ThriftTest_testBool_result&) noexcept;
  ThriftTest_testBool_result() noexcept
                             : success(0) {
  }

  virtual ~ThriftTest_testBool_result() noexcept;
  bool success;

  _ThriftTest_testBool_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const ThriftTest_testBool_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testBool_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testBool_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testBool_presult__isset {
  _ThriftTest_testBool_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testBool_presult__isset;

class ThriftTest_testBool_presult {
 public:


  virtual ~ThriftTest_testBool_presult() noexcept;
  bool* success;

  _ThriftTest_testBool_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testByte_args__isset {
  _ThriftTest_testByte_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testByte_args__isset;

class ThriftTest_testByte_args {
 public:

  ThriftTest_testByte_args(const ThriftTest_testByte_args&) noexcept;
  ThriftTest_testByte_args& operator=(const ThriftTest_testByte_args&) noexcept;
  ThriftTest_testByte_args() noexcept
                           : thing(0) {
  }

  virtual ~ThriftTest_testByte_args() noexcept;
  int8_t thing;

  _ThriftTest_testByte_args__isset __isset;

  void __set_thing(const int8_t val);

  bool operator == (const ThriftTest_testByte_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testByte_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testByte_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testByte_pargs {
 public:


  virtual ~ThriftTest_testByte_pargs() noexcept;
  const int8_t* thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testByte_result__isset {
  _ThriftTest_testByte_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testByte_result__isset;

class ThriftTest_testByte_result {
 public:

  ThriftTest_testByte_result(const ThriftTest_testByte_result&) noexcept;
  ThriftTest_testByte_result& operator=(const ThriftTest_testByte_result&) noexcept;
  ThriftTest_testByte_result() noexcept
                             : success(0) {
  }

  virtual ~ThriftTest_testByte_result() noexcept;
  int8_t success;

  _ThriftTest_testByte_result__isset __isset;

  void __set_success(const int8_t val);

  bool operator == (const ThriftTest_testByte_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testByte_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testByte_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testByte_presult__isset {
  _ThriftTest_testByte_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testByte_presult__isset;

class ThriftTest_testByte_presult {
 public:


  virtual ~ThriftTest_testByte_presult() noexcept;
  int8_t* success;

  _ThriftTest_testByte_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testI32_args__isset {
  _ThriftTest_testI32_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testI32_args__isset;

class ThriftTest_testI32_args {
 public:

  ThriftTest_testI32_args(const ThriftTest_testI32_args&) noexcept;
  ThriftTest_testI32_args& operator=(const ThriftTest_testI32_args&) noexcept;
  ThriftTest_testI32_args() noexcept
                          : thing(0) {
  }

  virtual ~ThriftTest_testI32_args() noexcept;
  int32_t thing;

  _ThriftTest_testI32_args__isset __isset;

  void __set_thing(const int32_t val);

  bool operator == (const ThriftTest_testI32_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testI32_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testI32_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testI32_pargs {
 public:


  virtual ~ThriftTest_testI32_pargs() noexcept;
  const int32_t* thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testI32_result__isset {
  _ThriftTest_testI32_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testI32_result__isset;

class ThriftTest_testI32_result {
 public:

  ThriftTest_testI32_result(const ThriftTest_testI32_result&) noexcept;
  ThriftTest_testI32_result& operator=(const ThriftTest_testI32_result&) noexcept;
  ThriftTest_testI32_result() noexcept
                            : success(0) {
  }

  virtual ~ThriftTest_testI32_result() noexcept;
  int32_t success;

  _ThriftTest_testI32_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const ThriftTest_testI32_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testI32_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testI32_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testI32_presult__isset {
  _ThriftTest_testI32_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testI32_presult__isset;

class ThriftTest_testI32_presult {
 public:


  virtual ~ThriftTest_testI32_presult() noexcept;
  int32_t* success;

  _ThriftTest_testI32_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testI64_args__isset {
  _ThriftTest_testI64_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testI64_args__isset;

class ThriftTest_testI64_args {
 public:

  ThriftTest_testI64_args(const ThriftTest_testI64_args&) noexcept;
  ThriftTest_testI64_args& operator=(const ThriftTest_testI64_args&) noexcept;
  ThriftTest_testI64_args() noexcept
                          : thing(0) {
  }

  virtual ~ThriftTest_testI64_args() noexcept;
  int64_t thing;

  _ThriftTest_testI64_args__isset __isset;

  void __set_thing(const int64_t val);

  bool operator == (const ThriftTest_testI64_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testI64_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testI64_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testI64_pargs {
 public:


  virtual ~ThriftTest_testI64_pargs() noexcept;
  const int64_t* thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testI64_result__isset {
  _ThriftTest_testI64_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testI64_result__isset;

class ThriftTest_testI64_result {
 public:

  ThriftTest_testI64_result(const ThriftTest_testI64_result&) noexcept;
  ThriftTest_testI64_result& operator=(const ThriftTest_testI64_result&) noexcept;
  ThriftTest_testI64_result() noexcept
                            : success(0) {
  }

  virtual ~ThriftTest_testI64_result() noexcept;
  int64_t success;

  _ThriftTest_testI64_result__isset __isset;

  void __set_success(const int64_t val);

  bool operator == (const ThriftTest_testI64_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testI64_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testI64_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testI64_presult__isset {
  _ThriftTest_testI64_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testI64_presult__isset;

class ThriftTest_testI64_presult {
 public:


  virtual ~ThriftTest_testI64_presult() noexcept;
  int64_t* success;

  _ThriftTest_testI64_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testDouble_args__isset {
  _ThriftTest_testDouble_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testDouble_args__isset;

class ThriftTest_testDouble_args {
 public:

  ThriftTest_testDouble_args(const ThriftTest_testDouble_args&) noexcept;
  ThriftTest_testDouble_args& operator=(const ThriftTest_testDouble_args&) noexcept;
  ThriftTest_testDouble_args() noexcept
                             : thing(0) {
  }

  virtual ~ThriftTest_testDouble_args() noexcept;
  double thing;

  _ThriftTest_testDouble_args__isset __isset;

  void __set_thing(const double val);

  bool operator == (const ThriftTest_testDouble_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testDouble_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testDouble_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testDouble_pargs {
 public:


  virtual ~ThriftTest_testDouble_pargs() noexcept;
  const double* thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testDouble_result__isset {
  _ThriftTest_testDouble_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testDouble_result__isset;

class ThriftTest_testDouble_result {
 public:

  ThriftTest_testDouble_result(const ThriftTest_testDouble_result&) noexcept;
  ThriftTest_testDouble_result& operator=(const ThriftTest_testDouble_result&) noexcept;
  ThriftTest_testDouble_result() noexcept
                               : success(0) {
  }

  virtual ~ThriftTest_testDouble_result() noexcept;
  double success;

  _ThriftTest_testDouble_result__isset __isset;

  void __set_success(const double val);

  bool operator == (const ThriftTest_testDouble_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testDouble_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testDouble_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testDouble_presult__isset {
  _ThriftTest_testDouble_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testDouble_presult__isset;

class ThriftTest_testDouble_presult {
 public:


  virtual ~ThriftTest_testDouble_presult() noexcept;
  double* success;

  _ThriftTest_testDouble_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testBinary_args__isset {
  _ThriftTest_testBinary_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testBinary_args__isset;

class ThriftTest_testBinary_args {
 public:

  ThriftTest_testBinary_args(const ThriftTest_testBinary_args&);
  ThriftTest_testBinary_args& operator=(const ThriftTest_testBinary_args&);
  ThriftTest_testBinary_args() noexcept
                             : thing() {
  }

  virtual ~ThriftTest_testBinary_args() noexcept;
  std::string thing;

  _ThriftTest_testBinary_args__isset __isset;

  void __set_thing(const std::string& val);

  bool operator == (const ThriftTest_testBinary_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testBinary_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testBinary_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testBinary_pargs {
 public:


  virtual ~ThriftTest_testBinary_pargs() noexcept;
  const std::string* thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testBinary_result__isset {
  _ThriftTest_testBinary_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testBinary_result__isset;

class ThriftTest_testBinary_result {
 public:

  ThriftTest_testBinary_result(const ThriftTest_testBinary_result&);
  ThriftTest_testBinary_result& operator=(const ThriftTest_testBinary_result&);
  ThriftTest_testBinary_result() noexcept
                               : success() {
  }

  virtual ~ThriftTest_testBinary_result() noexcept;
  std::string success;

  _ThriftTest_testBinary_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const ThriftTest_testBinary_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testBinary_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testBinary_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testBinary_presult__isset {
  _ThriftTest_testBinary_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testBinary_presult__isset;

class ThriftTest_testBinary_presult {
 public:


  virtual ~ThriftTest_testBinary_presult() noexcept;
  std::string* success;

  _ThriftTest_testBinary_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testStruct_args__isset {
  _ThriftTest_testStruct_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testStruct_args__isset;

class ThriftTest_testStruct_args {
 public:

  ThriftTest_testStruct_args(const ThriftTest_testStruct_args&);
  ThriftTest_testStruct_args& operator=(const ThriftTest_testStruct_args&);
  ThriftTest_testStruct_args() noexcept {
  }

  virtual ~ThriftTest_testStruct_args() noexcept;
  Xtruct thing;

  _ThriftTest_testStruct_args__isset __isset;

  void __set_thing(const Xtruct& val);

  bool operator == (const ThriftTest_testStruct_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testStruct_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testStruct_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testStruct_pargs {
 public:


  virtual ~ThriftTest_testStruct_pargs() noexcept;
  const Xtruct* thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testStruct_result__isset {
  _ThriftTest_testStruct_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testStruct_result__isset;

class ThriftTest_testStruct_result {
 public:

  ThriftTest_testStruct_result(const ThriftTest_testStruct_result&);
  ThriftTest_testStruct_result& operator=(const ThriftTest_testStruct_result&);
  ThriftTest_testStruct_result() noexcept {
  }

  virtual ~ThriftTest_testStruct_result() noexcept;
  Xtruct success;

  _ThriftTest_testStruct_result__isset __isset;

  void __set_success(const Xtruct& val);

  bool operator == (const ThriftTest_testStruct_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testStruct_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testStruct_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testStruct_presult__isset {
  _ThriftTest_testStruct_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testStruct_presult__isset;

class ThriftTest_testStruct_presult {
 public:


  virtual ~ThriftTest_testStruct_presult() noexcept;
  Xtruct* success;

  _ThriftTest_testStruct_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testNest_args__isset {
  _ThriftTest_testNest_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testNest_args__isset;

class ThriftTest_testNest_args {
 public:

  ThriftTest_testNest_args(const ThriftTest_testNest_args&);
  ThriftTest_testNest_args& operator=(const ThriftTest_testNest_args&);
  ThriftTest_testNest_args() noexcept {
  }

  virtual ~ThriftTest_testNest_args() noexcept;
  Xtruct2 thing;

  _ThriftTest_testNest_args__isset __isset;

  void __set_thing(const Xtruct2& val);

  bool operator == (const ThriftTest_testNest_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testNest_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testNest_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testNest_pargs {
 public:


  virtual ~ThriftTest_testNest_pargs() noexcept;
  const Xtruct2* thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testNest_result__isset {
  _ThriftTest_testNest_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testNest_result__isset;

class ThriftTest_testNest_result {
 public:

  ThriftTest_testNest_result(const ThriftTest_testNest_result&);
  ThriftTest_testNest_result& operator=(const ThriftTest_testNest_result&);
  ThriftTest_testNest_result() noexcept {
  }

  virtual ~ThriftTest_testNest_result() noexcept;
  Xtruct2 success;

  _ThriftTest_testNest_result__isset __isset;

  void __set_success(const Xtruct2& val);

  bool operator == (const ThriftTest_testNest_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testNest_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testNest_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testNest_presult__isset {
  _ThriftTest_testNest_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testNest_presult__isset;

class ThriftTest_testNest_presult {
 public:


  virtual ~ThriftTest_testNest_presult() noexcept;
  Xtruct2* success;

  _ThriftTest_testNest_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testMap_args__isset {
  _ThriftTest_testMap_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testMap_args__isset;

class ThriftTest_testMap_args {
 public:

  ThriftTest_testMap_args(const ThriftTest_testMap_args&);
  ThriftTest_testMap_args& operator=(const ThriftTest_testMap_args&);
  ThriftTest_testMap_args() noexcept {
  }

  virtual ~ThriftTest_testMap_args() noexcept;
  std::map<int32_t, int32_t>  thing;

  _ThriftTest_testMap_args__isset __isset;

  void __set_thing(const std::map<int32_t, int32_t> & val);

  bool operator == (const ThriftTest_testMap_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testMap_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testMap_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testMap_pargs {
 public:


  virtual ~ThriftTest_testMap_pargs() noexcept;
  const std::map<int32_t, int32_t> * thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testMap_result__isset {
  _ThriftTest_testMap_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testMap_result__isset;

class ThriftTest_testMap_result {
 public:

  ThriftTest_testMap_result(const ThriftTest_testMap_result&);
  ThriftTest_testMap_result& operator=(const ThriftTest_testMap_result&);
  ThriftTest_testMap_result() noexcept {
  }

  virtual ~ThriftTest_testMap_result() noexcept;
  std::map<int32_t, int32_t>  success;

  _ThriftTest_testMap_result__isset __isset;

  void __set_success(const std::map<int32_t, int32_t> & val);

  bool operator == (const ThriftTest_testMap_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testMap_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testMap_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testMap_presult__isset {
  _ThriftTest_testMap_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testMap_presult__isset;

class ThriftTest_testMap_presult {
 public:


  virtual ~ThriftTest_testMap_presult() noexcept;
  std::map<int32_t, int32_t> * success;

  _ThriftTest_testMap_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testStringMap_args__isset {
  _ThriftTest_testStringMap_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testStringMap_args__isset;

class ThriftTest_testStringMap_args {
 public:

  ThriftTest_testStringMap_args(const ThriftTest_testStringMap_args&);
  ThriftTest_testStringMap_args& operator=(const ThriftTest_testStringMap_args&);
  ThriftTest_testStringMap_args() noexcept {
  }

  virtual ~ThriftTest_testStringMap_args() noexcept;
  std::map<std::string, std::string>  thing;

  _ThriftTest_testStringMap_args__isset __isset;

  void __set_thing(const std::map<std::string, std::string> & val);

  bool operator == (const ThriftTest_testStringMap_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testStringMap_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testStringMap_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testStringMap_pargs {
 public:


  virtual ~ThriftTest_testStringMap_pargs() noexcept;
  const std::map<std::string, std::string> * thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testStringMap_result__isset {
  _ThriftTest_testStringMap_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testStringMap_result__isset;

class ThriftTest_testStringMap_result {
 public:

  ThriftTest_testStringMap_result(const ThriftTest_testStringMap_result&);
  ThriftTest_testStringMap_result& operator=(const ThriftTest_testStringMap_result&);
  ThriftTest_testStringMap_result() noexcept {
  }

  virtual ~ThriftTest_testStringMap_result() noexcept;
  std::map<std::string, std::string>  success;

  _ThriftTest_testStringMap_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val);

  bool operator == (const ThriftTest_testStringMap_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testStringMap_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testStringMap_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testStringMap_presult__isset {
  _ThriftTest_testStringMap_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testStringMap_presult__isset;

class ThriftTest_testStringMap_presult {
 public:


  virtual ~ThriftTest_testStringMap_presult() noexcept;
  std::map<std::string, std::string> * success;

  _ThriftTest_testStringMap_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testSet_args__isset {
  _ThriftTest_testSet_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testSet_args__isset;

class ThriftTest_testSet_args {
 public:

  ThriftTest_testSet_args(const ThriftTest_testSet_args&);
  ThriftTest_testSet_args& operator=(const ThriftTest_testSet_args&);
  ThriftTest_testSet_args() noexcept {
  }

  virtual ~ThriftTest_testSet_args() noexcept;
  std::set<int32_t>  thing;

  _ThriftTest_testSet_args__isset __isset;

  void __set_thing(const std::set<int32_t> & val);

  bool operator == (const ThriftTest_testSet_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testSet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testSet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testSet_pargs {
 public:


  virtual ~ThriftTest_testSet_pargs() noexcept;
  const std::set<int32_t> * thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testSet_result__isset {
  _ThriftTest_testSet_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testSet_result__isset;

class ThriftTest_testSet_result {
 public:

  ThriftTest_testSet_result(const ThriftTest_testSet_result&);
  ThriftTest_testSet_result& operator=(const ThriftTest_testSet_result&);
  ThriftTest_testSet_result() noexcept {
  }

  virtual ~ThriftTest_testSet_result() noexcept;
  std::set<int32_t>  success;

  _ThriftTest_testSet_result__isset __isset;

  void __set_success(const std::set<int32_t> & val);

  bool operator == (const ThriftTest_testSet_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testSet_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testSet_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testSet_presult__isset {
  _ThriftTest_testSet_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testSet_presult__isset;

class ThriftTest_testSet_presult {
 public:


  virtual ~ThriftTest_testSet_presult() noexcept;
  std::set<int32_t> * success;

  _ThriftTest_testSet_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testList_args__isset {
  _ThriftTest_testList_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testList_args__isset;

class ThriftTest_testList_args {
 public:

  ThriftTest_testList_args(const ThriftTest_testList_args&);
  ThriftTest_testList_args& operator=(const ThriftTest_testList_args&);
  ThriftTest_testList_args() noexcept {
  }

  virtual ~ThriftTest_testList_args() noexcept;
  std::vector<int32_t>  thing;

  _ThriftTest_testList_args__isset __isset;

  void __set_thing(const std::vector<int32_t> & val);

  bool operator == (const ThriftTest_testList_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testList_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testList_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testList_pargs {
 public:


  virtual ~ThriftTest_testList_pargs() noexcept;
  const std::vector<int32_t> * thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testList_result__isset {
  _ThriftTest_testList_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testList_result__isset;

class ThriftTest_testList_result {
 public:

  ThriftTest_testList_result(const ThriftTest_testList_result&);
  ThriftTest_testList_result& operator=(const ThriftTest_testList_result&);
  ThriftTest_testList_result() noexcept {
  }

  virtual ~ThriftTest_testList_result() noexcept;
  std::vector<int32_t>  success;

  _ThriftTest_testList_result__isset __isset;

  void __set_success(const std::vector<int32_t> & val);

  bool operator == (const ThriftTest_testList_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testList_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testList_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testList_presult__isset {
  _ThriftTest_testList_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testList_presult__isset;

class ThriftTest_testList_presult {
 public:


  virtual ~ThriftTest_testList_presult() noexcept;
  std::vector<int32_t> * success;

  _ThriftTest_testList_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testEnum_args__isset {
  _ThriftTest_testEnum_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testEnum_args__isset;

class ThriftTest_testEnum_args {
 public:

  ThriftTest_testEnum_args(const ThriftTest_testEnum_args&) noexcept;
  ThriftTest_testEnum_args& operator=(const ThriftTest_testEnum_args&) noexcept;
  ThriftTest_testEnum_args() noexcept
                           : thing(static_cast<Numberz::type>(0)) {
  }

  virtual ~ThriftTest_testEnum_args() noexcept;
  /**
   * 
   * @see Numberz
   */
  Numberz::type thing;

  _ThriftTest_testEnum_args__isset __isset;

  void __set_thing(const Numberz::type val);

  bool operator == (const ThriftTest_testEnum_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testEnum_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testEnum_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testEnum_pargs {
 public:


  virtual ~ThriftTest_testEnum_pargs() noexcept;
  /**
   * 
   * @see Numberz
   */
  const Numberz::type* thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testEnum_result__isset {
  _ThriftTest_testEnum_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testEnum_result__isset;

class ThriftTest_testEnum_result {
 public:

  ThriftTest_testEnum_result(const ThriftTest_testEnum_result&) noexcept;
  ThriftTest_testEnum_result& operator=(const ThriftTest_testEnum_result&) noexcept;
  ThriftTest_testEnum_result() noexcept
                             : success(static_cast<Numberz::type>(0)) {
  }

  virtual ~ThriftTest_testEnum_result() noexcept;
  /**
   * 
   * @see Numberz
   */
  Numberz::type success;

  _ThriftTest_testEnum_result__isset __isset;

  void __set_success(const Numberz::type val);

  bool operator == (const ThriftTest_testEnum_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testEnum_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testEnum_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testEnum_presult__isset {
  _ThriftTest_testEnum_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testEnum_presult__isset;

class ThriftTest_testEnum_presult {
 public:


  virtual ~ThriftTest_testEnum_presult() noexcept;
  /**
   * 
   * @see Numberz
   */
  Numberz::type* success;

  _ThriftTest_testEnum_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testTypedef_args__isset {
  _ThriftTest_testTypedef_args__isset() : thing(false) {}
  bool thing :1;
} _ThriftTest_testTypedef_args__isset;

class ThriftTest_testTypedef_args {
 public:

  ThriftTest_testTypedef_args(const ThriftTest_testTypedef_args&) noexcept;
  ThriftTest_testTypedef_args& operator=(const ThriftTest_testTypedef_args&) noexcept;
  ThriftTest_testTypedef_args() noexcept
                              : thing(0) {
  }

  virtual ~ThriftTest_testTypedef_args() noexcept;
  UserId thing;

  _ThriftTest_testTypedef_args__isset __isset;

  void __set_thing(const UserId val);

  bool operator == (const ThriftTest_testTypedef_args & rhs) const
  {
    if (!(thing == rhs.thing))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testTypedef_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testTypedef_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testTypedef_pargs {
 public:


  virtual ~ThriftTest_testTypedef_pargs() noexcept;
  const UserId* thing;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testTypedef_result__isset {
  _ThriftTest_testTypedef_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testTypedef_result__isset;

class ThriftTest_testTypedef_result {
 public:

  ThriftTest_testTypedef_result(const ThriftTest_testTypedef_result&) noexcept;
  ThriftTest_testTypedef_result& operator=(const ThriftTest_testTypedef_result&) noexcept;
  ThriftTest_testTypedef_result() noexcept
                                : success(0) {
  }

  virtual ~ThriftTest_testTypedef_result() noexcept;
  UserId success;

  _ThriftTest_testTypedef_result__isset __isset;

  void __set_success(const UserId val);

  bool operator == (const ThriftTest_testTypedef_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testTypedef_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testTypedef_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testTypedef_presult__isset {
  _ThriftTest_testTypedef_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testTypedef_presult__isset;

class ThriftTest_testTypedef_presult {
 public:


  virtual ~ThriftTest_testTypedef_presult() noexcept;
  UserId* success;

  _ThriftTest_testTypedef_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testMapMap_args__isset {
  _ThriftTest_testMapMap_args__isset() : hello(false) {}
  bool hello :1;
} _ThriftTest_testMapMap_args__isset;

class ThriftTest_testMapMap_args {
 public:

  ThriftTest_testMapMap_args(const ThriftTest_testMapMap_args&) noexcept;
  ThriftTest_testMapMap_args& operator=(const ThriftTest_testMapMap_args&) noexcept;
  ThriftTest_testMapMap_args() noexcept
                             : hello(0) {
  }

  virtual ~ThriftTest_testMapMap_args() noexcept;
  int32_t hello;

  _ThriftTest_testMapMap_args__isset __isset;

  void __set_hello(const int32_t val);

  bool operator == (const ThriftTest_testMapMap_args & rhs) const
  {
    if (!(hello == rhs.hello))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testMapMap_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testMapMap_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testMapMap_pargs {
 public:


  virtual ~ThriftTest_testMapMap_pargs() noexcept;
  const int32_t* hello;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testMapMap_result__isset {
  _ThriftTest_testMapMap_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testMapMap_result__isset;

class ThriftTest_testMapMap_result {
 public:

  ThriftTest_testMapMap_result(const ThriftTest_testMapMap_result&);
  ThriftTest_testMapMap_result& operator=(const ThriftTest_testMapMap_result&);
  ThriftTest_testMapMap_result() noexcept {
  }

  virtual ~ThriftTest_testMapMap_result() noexcept;
  std::map<int32_t, std::map<int32_t, int32_t> >  success;

  _ThriftTest_testMapMap_result__isset __isset;

  void __set_success(const std::map<int32_t, std::map<int32_t, int32_t> > & val);

  bool operator == (const ThriftTest_testMapMap_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testMapMap_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testMapMap_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testMapMap_presult__isset {
  _ThriftTest_testMapMap_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testMapMap_presult__isset;

class ThriftTest_testMapMap_presult {
 public:


  virtual ~ThriftTest_testMapMap_presult() noexcept;
  std::map<int32_t, std::map<int32_t, int32_t> > * success;

  _ThriftTest_testMapMap_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testInsanity_args__isset {
  _ThriftTest_testInsanity_args__isset() : argument(false) {}
  bool argument :1;
} _ThriftTest_testInsanity_args__isset;

class ThriftTest_testInsanity_args {
 public:

  ThriftTest_testInsanity_args(const ThriftTest_testInsanity_args&);
  ThriftTest_testInsanity_args& operator=(const ThriftTest_testInsanity_args&);
  ThriftTest_testInsanity_args() noexcept {
  }

  virtual ~ThriftTest_testInsanity_args() noexcept;
  Insanity argument;

  _ThriftTest_testInsanity_args__isset __isset;

  void __set_argument(const Insanity& val);

  bool operator == (const ThriftTest_testInsanity_args & rhs) const
  {
    if (!(argument == rhs.argument))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testInsanity_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testInsanity_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testInsanity_pargs {
 public:


  virtual ~ThriftTest_testInsanity_pargs() noexcept;
  const Insanity* argument;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testInsanity_result__isset {
  _ThriftTest_testInsanity_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testInsanity_result__isset;

class ThriftTest_testInsanity_result {
 public:

  ThriftTest_testInsanity_result(const ThriftTest_testInsanity_result&);
  ThriftTest_testInsanity_result& operator=(const ThriftTest_testInsanity_result&);
  ThriftTest_testInsanity_result() noexcept {
  }

  virtual ~ThriftTest_testInsanity_result() noexcept;
  std::map<UserId, std::map<Numberz::type, Insanity> >  success;

  _ThriftTest_testInsanity_result__isset __isset;

  void __set_success(const std::map<UserId, std::map<Numberz::type, Insanity> > & val);

  bool operator == (const ThriftTest_testInsanity_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testInsanity_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testInsanity_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testInsanity_presult__isset {
  _ThriftTest_testInsanity_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testInsanity_presult__isset;

class ThriftTest_testInsanity_presult {
 public:


  virtual ~ThriftTest_testInsanity_presult() noexcept;
  std::map<UserId, std::map<Numberz::type, Insanity> > * success;

  _ThriftTest_testInsanity_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testMulti_args__isset {
  _ThriftTest_testMulti_args__isset() : arg0(false), arg1(false), arg2(false), arg3(false), arg4(false), arg5(false) {}
  bool arg0 :1;
  bool arg1 :1;
  bool arg2 :1;
  bool arg3 :1;
  bool arg4 :1;
  bool arg5 :1;
} _ThriftTest_testMulti_args__isset;

class ThriftTest_testMulti_args {
 public:

  ThriftTest_testMulti_args(const ThriftTest_testMulti_args&);
  ThriftTest_testMulti_args& operator=(const ThriftTest_testMulti_args&);
  ThriftTest_testMulti_args() noexcept
                            : arg0(0),
                              arg1(0),
                              arg2(0),
                              arg4(static_cast<Numberz::type>(0)),
                              arg5(0) {
  }

  virtual ~ThriftTest_testMulti_args() noexcept;
  int8_t arg0;
  int32_t arg1;
  int64_t arg2;
  std::map<int16_t, std::string>  arg3;
  /**
   * 
   * @see Numberz
   */
  Numberz::type arg4;
  UserId arg5;

  _ThriftTest_testMulti_args__isset __isset;

  void __set_arg0(const int8_t val);

  void __set_arg1(const int32_t val);

  void __set_arg2(const int64_t val);

  void __set_arg3(const std::map<int16_t, std::string> & val);

  void __set_arg4(const Numberz::type val);

  void __set_arg5(const UserId val);

  bool operator == (const ThriftTest_testMulti_args & rhs) const
  {
    if (!(arg0 == rhs.arg0))
      return false;
    if (!(arg1 == rhs.arg1))
      return false;
    if (!(arg2 == rhs.arg2))
      return false;
    if (!(arg3 == rhs.arg3))
      return false;
    if (!(arg4 == rhs.arg4))
      return false;
    if (!(arg5 == rhs.arg5))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testMulti_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testMulti_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testMulti_pargs {
 public:


  virtual ~ThriftTest_testMulti_pargs() noexcept;
  const int8_t* arg0;
  const int32_t* arg1;
  const int64_t* arg2;
  const std::map<int16_t, std::string> * arg3;
  /**
   * 
   * @see Numberz
   */
  const Numberz::type* arg4;
  const UserId* arg5;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testMulti_result__isset {
  _ThriftTest_testMulti_result__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testMulti_result__isset;

class ThriftTest_testMulti_result {
 public:

  ThriftTest_testMulti_result(const ThriftTest_testMulti_result&);
  ThriftTest_testMulti_result& operator=(const ThriftTest_testMulti_result&);
  ThriftTest_testMulti_result() noexcept {
  }

  virtual ~ThriftTest_testMulti_result() noexcept;
  Xtruct success;

  _ThriftTest_testMulti_result__isset __isset;

  void __set_success(const Xtruct& val);

  bool operator == (const ThriftTest_testMulti_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testMulti_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testMulti_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testMulti_presult__isset {
  _ThriftTest_testMulti_presult__isset() : success(false) {}
  bool success :1;
} _ThriftTest_testMulti_presult__isset;

class ThriftTest_testMulti_presult {
 public:


  virtual ~ThriftTest_testMulti_presult() noexcept;
  Xtruct* success;

  _ThriftTest_testMulti_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testException_args__isset {
  _ThriftTest_testException_args__isset() : arg(false) {}
  bool arg :1;
} _ThriftTest_testException_args__isset;

class ThriftTest_testException_args {
 public:

  ThriftTest_testException_args(const ThriftTest_testException_args&);
  ThriftTest_testException_args& operator=(const ThriftTest_testException_args&);
  ThriftTest_testException_args() noexcept
                                : arg() {
  }

  virtual ~ThriftTest_testException_args() noexcept;
  std::string arg;

  _ThriftTest_testException_args__isset __isset;

  void __set_arg(const std::string& val);

  bool operator == (const ThriftTest_testException_args & rhs) const
  {
    if (!(arg == rhs.arg))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testException_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testException_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testException_pargs {
 public:


  virtual ~ThriftTest_testException_pargs() noexcept;
  const std::string* arg;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testException_result__isset {
  _ThriftTest_testException_result__isset() : err1(false) {}
  bool err1 :1;
} _ThriftTest_testException_result__isset;

class ThriftTest_testException_result {
 public:

  ThriftTest_testException_result(const ThriftTest_testException_result&);
  ThriftTest_testException_result& operator=(const ThriftTest_testException_result&);
  ThriftTest_testException_result() noexcept {
  }

  virtual ~ThriftTest_testException_result() noexcept;
  Xception err1;

  _ThriftTest_testException_result__isset __isset;

  void __set_err1(const Xception& val);

  bool operator == (const ThriftTest_testException_result & rhs) const
  {
    if (!(err1 == rhs.err1))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testException_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testException_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testException_presult__isset {
  _ThriftTest_testException_presult__isset() : err1(false) {}
  bool err1 :1;
} _ThriftTest_testException_presult__isset;

class ThriftTest_testException_presult {
 public:


  virtual ~ThriftTest_testException_presult() noexcept;
  Xception err1;

  _ThriftTest_testException_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testMultiException_args__isset {
  _ThriftTest_testMultiException_args__isset() : arg0(false), arg1(false) {}
  bool arg0 :1;
  bool arg1 :1;
} _ThriftTest_testMultiException_args__isset;

class ThriftTest_testMultiException_args {
 public:

  ThriftTest_testMultiException_args(const ThriftTest_testMultiException_args&);
  ThriftTest_testMultiException_args& operator=(const ThriftTest_testMultiException_args&);
  ThriftTest_testMultiException_args() noexcept
                                     : arg0(),
                                       arg1() {
  }

  virtual ~ThriftTest_testMultiException_args() noexcept;
  std::string arg0;
  std::string arg1;

  _ThriftTest_testMultiException_args__isset __isset;

  void __set_arg0(const std::string& val);

  void __set_arg1(const std::string& val);

  bool operator == (const ThriftTest_testMultiException_args & rhs) const
  {
    if (!(arg0 == rhs.arg0))
      return false;
    if (!(arg1 == rhs.arg1))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testMultiException_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testMultiException_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testMultiException_pargs {
 public:


  virtual ~ThriftTest_testMultiException_pargs() noexcept;
  const std::string* arg0;
  const std::string* arg1;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testMultiException_result__isset {
  _ThriftTest_testMultiException_result__isset() : success(false), err1(false), err2(false) {}
  bool success :1;
  bool err1 :1;
  bool err2 :1;
} _ThriftTest_testMultiException_result__isset;

class ThriftTest_testMultiException_result {
 public:

  ThriftTest_testMultiException_result(const ThriftTest_testMultiException_result&);
  ThriftTest_testMultiException_result& operator=(const ThriftTest_testMultiException_result&);
  ThriftTest_testMultiException_result() noexcept {
  }

  virtual ~ThriftTest_testMultiException_result() noexcept;
  Xtruct success;
  Xception err1;
  Xception2 err2;

  _ThriftTest_testMultiException_result__isset __isset;

  void __set_success(const Xtruct& val);

  void __set_err1(const Xception& val);

  void __set_err2(const Xception2& val);

  bool operator == (const ThriftTest_testMultiException_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(err1 == rhs.err1))
      return false;
    if (!(err2 == rhs.err2))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testMultiException_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testMultiException_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ThriftTest_testMultiException_presult__isset {
  _ThriftTest_testMultiException_presult__isset() : success(false), err1(false), err2(false) {}
  bool success :1;
  bool err1 :1;
  bool err2 :1;
} _ThriftTest_testMultiException_presult__isset;

class ThriftTest_testMultiException_presult {
 public:


  virtual ~ThriftTest_testMultiException_presult() noexcept;
  Xtruct* success;
  Xception err1;
  Xception2 err2;

  _ThriftTest_testMultiException_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ThriftTest_testOneway_args__isset {
  _ThriftTest_testOneway_args__isset() : secondsToSleep(false) {}
  bool secondsToSleep :1;
} _ThriftTest_testOneway_args__isset;

class ThriftTest_testOneway_args {
 public:

  ThriftTest_testOneway_args(const ThriftTest_testOneway_args&) noexcept;
  ThriftTest_testOneway_args& operator=(const ThriftTest_testOneway_args&) noexcept;
  ThriftTest_testOneway_args() noexcept
                             : secondsToSleep(0) {
  }

  virtual ~ThriftTest_testOneway_args() noexcept;
  int32_t secondsToSleep;

  _ThriftTest_testOneway_args__isset __isset;

  void __set_secondsToSleep(const int32_t val);

  bool operator == (const ThriftTest_testOneway_args & rhs) const
  {
    if (!(secondsToSleep == rhs.secondsToSleep))
      return false;
    return true;
  }
  bool operator != (const ThriftTest_testOneway_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ThriftTest_testOneway_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ThriftTest_testOneway_pargs {
 public:


  virtual ~ThriftTest_testOneway_pargs() noexcept;
  const int32_t* secondsToSleep;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class ThriftTestClient : virtual public ThriftTestIf {
 public:
  ThriftTestClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ThriftTestClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * Prints "testVoid()" and returns nothing.
   */
  void testVoid() override;
  void send_testVoid();
  void recv_testVoid();
  /**
   * Prints 'testString("%s")' with thing as '%s'
   * @param string thing - the string to print
   * @return string - returns the string 'thing'
   * 
   * @param thing
   */
  void testString(std::string& _return, const std::string& thing) override;
  void send_testString(const std::string& thing);
  void recv_testString(std::string& _return);
  /**
   * Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
   * @param bool  thing - the bool data to print
   * @return bool  - returns the bool 'thing'
   * 
   * @param thing
   */
  bool testBool(const bool thing) override;
  void send_testBool(const bool thing);
  bool recv_testBool();
  /**
   * Prints 'testByte("%d")' with thing as '%d'
   * The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
   * @param byte thing - the i8/byte to print
   * @return i8 - returns the i8/byte 'thing'
   * 
   * @param thing
   */
  int8_t testByte(const int8_t thing) override;
  void send_testByte(const int8_t thing);
  int8_t recv_testByte();
  /**
   * Prints 'testI32("%d")' with thing as '%d'
   * @param i32 thing - the i32 to print
   * @return i32 - returns the i32 'thing'
   * 
   * @param thing
   */
  int32_t testI32(const int32_t thing) override;
  void send_testI32(const int32_t thing);
  int32_t recv_testI32();
  /**
   * Prints 'testI64("%d")' with thing as '%d'
   * @param i64 thing - the i64 to print
   * @return i64 - returns the i64 'thing'
   * 
   * @param thing
   */
  int64_t testI64(const int64_t thing) override;
  void send_testI64(const int64_t thing);
  int64_t recv_testI64();
  /**
   * Prints 'testDouble("%f")' with thing as '%f'
   * @param double thing - the double to print
   * @return double - returns the double 'thing'
   * 
   * @param thing
   */
  double testDouble(const double thing) override;
  void send_testDouble(const double thing);
  double recv_testDouble();
  /**
   * Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
   * @param binary  thing - the binary data to print
   * @return binary  - returns the binary 'thing'
   * 
   * @param thing
   */
  void testBinary(std::string& _return, const std::string& thing) override;
  void send_testBinary(const std::string& thing);
  void recv_testBinary(std::string& _return);
  /**
   * Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
   * @param Xtruct thing - the Xtruct to print
   * @return Xtruct - returns the Xtruct 'thing'
   * 
   * @param thing
   */
  void testStruct(Xtruct& _return, const Xtruct& thing) override;
  void send_testStruct(const Xtruct& thing);
  void recv_testStruct(Xtruct& _return);
  /**
   * Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
   * @param Xtruct2 thing - the Xtruct2 to print
   * @return Xtruct2 - returns the Xtruct2 'thing'
   * 
   * @param thing
   */
  void testNest(Xtruct2& _return, const Xtruct2& thing) override;
  void send_testNest(const Xtruct2& thing);
  void recv_testNest(Xtruct2& _return);
  /**
   * Prints 'testMap("{%s")' where thing has been formatted into a string of 'key => value' pairs
   *  separated by commas and new lines
   * @param map<i32,i32> thing - the map<i32,i32> to print
   * @return map<i32,i32> - returns the map<i32,i32> 'thing'
   * 
   * @param thing
   */
  void testMap(std::map<int32_t, int32_t> & _return, const std::map<int32_t, int32_t> & thing) override;
  void send_testMap(const std::map<int32_t, int32_t> & thing);
  void recv_testMap(std::map<int32_t, int32_t> & _return);
  /**
   * Prints 'testStringMap("{%s}")' where thing has been formatted into a string of 'key => value' pairs
   *  separated by commas and new lines
   * @param map<string,string> thing - the map<string,string> to print
   * @return map<string,string> - returns the map<string,string> 'thing'
   * 
   * @param thing
   */
  void testStringMap(std::map<std::string, std::string> & _return, const std::map<std::string, std::string> & thing) override;
  void send_testStringMap(const std::map<std::string, std::string> & thing);
  void recv_testStringMap(std::map<std::string, std::string> & _return);
  /**
   * Prints 'testSet("{%s}")' where thing has been formatted into a string of values
   *  separated by commas and new lines
   * @param set<i32> thing - the set<i32> to print
   * @return set<i32> - returns the set<i32> 'thing'
   * 
   * @param thing
   */
  void testSet(std::set<int32_t> & _return, const std::set<int32_t> & thing) override;
  void send_testSet(const std::set<int32_t> & thing);
  void recv_testSet(std::set<int32_t> & _return);
  /**
   * Prints 'testList("{%s}")' where thing has been formatted into a string of values
   *  separated by commas and new lines
   * @param list<i32> thing - the list<i32> to print
   * @return list<i32> - returns the list<i32> 'thing'
   * 
   * @param thing
   */
  void testList(std::vector<int32_t> & _return, const std::vector<int32_t> & thing) override;
  void send_testList(const std::vector<int32_t> & thing);
  void recv_testList(std::vector<int32_t> & _return);
  /**
   * Prints 'testEnum("%d")' where thing has been formatted into its numeric value
   * @param Numberz thing - the Numberz to print
   * @return Numberz - returns the Numberz 'thing'
   * 
   * @param thing
   */
  Numberz::type testEnum(const Numberz::type thing) override;
  void send_testEnum(const Numberz::type thing);
  Numberz::type recv_testEnum();
  /**
   * Prints 'testTypedef("%d")' with thing as '%d'
   * @param UserId thing - the UserId to print
   * @return UserId - returns the UserId 'thing'
   * 
   * @param thing
   */
  UserId testTypedef(const UserId thing) override;
  void send_testTypedef(const UserId thing);
  UserId recv_testTypedef();
  /**
   * Prints 'testMapMap("%d")' with hello as '%d'
   * @param i32 hello - the i32 to print
   * @return map<i32,map<i32,i32>> - returns a dictionary with these values:
   *   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
   * 
   * @param hello
   */
  void testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t hello) override;
  void send_testMapMap(const int32_t hello);
  void recv_testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return);
  /**
   * So you think you've got this all worked out, eh?
   * 
   * Creates a map with these values and prints it out:
   *   { 1 => { 2 => argument,
   *            3 => argument,
   *          },
   *     2 => { 6 => <empty Insanity struct>, },
   *   }
   * @return map<UserId, map<Numberz,Insanity>> - a map with the above values
   * 
   * @param argument
   */
  void testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const Insanity& argument) override;
  void send_testInsanity(const Insanity& argument);
  void recv_testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return);
  /**
   * Prints 'testMulti()'
   * @param i8 arg0 -
   * @param i32 arg1 -
   * @param i64 arg2 -
   * @param map<i16, string> arg3 -
   * @param Numberz arg4 -
   * @param UserId arg5 -
   * @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
   *    and i64_thing = arg2
   * 
   * @param arg0
   * @param arg1
   * @param arg2
   * @param arg3
   * @param arg4
   * @param arg5
   */
  void testMulti(Xtruct& _return, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5) override;
  void send_testMulti(const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5);
  void recv_testMulti(Xtruct& _return);
  /**
   * Print 'testException(%s)' with arg as '%s'
   * @param string arg - a string indication what type of exception to throw
   * if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
   * else if arg == "TException" throw TException
   * else do not throw anything
   * 
   * @param arg
   */
  void testException(const std::string& arg) override;
  void send_testException(const std::string& arg);
  void recv_testException();
  /**
   * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
   * @param string arg - a string indicating what type of exception to throw
   * if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
   * else if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
   * else do not throw anything
   * @return Xtruct - an Xtruct with string_thing = arg1
   * 
   * @param arg0
   * @param arg1
   */
  void testMultiException(Xtruct& _return, const std::string& arg0, const std::string& arg1) override;
  void send_testMultiException(const std::string& arg0, const std::string& arg1);
  void recv_testMultiException(Xtruct& _return);
  /**
   * Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
   * sleep 'secondsToSleep'
   * Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
   * @param i32 secondsToSleep - the number of seconds to sleep
   * 
   * @param secondsToSleep
   */
  void testOneway(const int32_t secondsToSleep) override;
  void send_testOneway(const int32_t secondsToSleep);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ThriftTestProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<ThriftTestIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) override;
 private:
  typedef  void (ThriftTestProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_testVoid(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testString(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testBool(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testByte(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testI32(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testI64(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testDouble(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testBinary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testStruct(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testNest(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testStringMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testSet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testEnum(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testTypedef(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testMapMap(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testInsanity(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testMulti(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testException(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testMultiException(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_testOneway(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ThriftTestProcessor(::std::shared_ptr<ThriftTestIf> iface) :
    iface_(iface) {
    processMap_["testVoid"] = &ThriftTestProcessor::process_testVoid;
    processMap_["testString"] = &ThriftTestProcessor::process_testString;
    processMap_["testBool"] = &ThriftTestProcessor::process_testBool;
    processMap_["testByte"] = &ThriftTestProcessor::process_testByte;
    processMap_["testI32"] = &ThriftTestProcessor::process_testI32;
    processMap_["testI64"] = &ThriftTestProcessor::process_testI64;
    processMap_["testDouble"] = &ThriftTestProcessor::process_testDouble;
    processMap_["testBinary"] = &ThriftTestProcessor::process_testBinary;
    processMap_["testStruct"] = &ThriftTestProcessor::process_testStruct;
    processMap_["testNest"] = &ThriftTestProcessor::process_testNest;
    processMap_["testMap"] = &ThriftTestProcessor::process_testMap;
    processMap_["testStringMap"] = &ThriftTestProcessor::process_testStringMap;
    processMap_["testSet"] = &ThriftTestProcessor::process_testSet;
    processMap_["testList"] = &ThriftTestProcessor::process_testList;
    processMap_["testEnum"] = &ThriftTestProcessor::process_testEnum;
    processMap_["testTypedef"] = &ThriftTestProcessor::process_testTypedef;
    processMap_["testMapMap"] = &ThriftTestProcessor::process_testMapMap;
    processMap_["testInsanity"] = &ThriftTestProcessor::process_testInsanity;
    processMap_["testMulti"] = &ThriftTestProcessor::process_testMulti;
    processMap_["testException"] = &ThriftTestProcessor::process_testException;
    processMap_["testMultiException"] = &ThriftTestProcessor::process_testMultiException;
    processMap_["testOneway"] = &ThriftTestProcessor::process_testOneway;
  }

  virtual ~ThriftTestProcessor() {}
};

class ThriftTestProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ThriftTestProcessorFactory(const ::std::shared_ptr< ThriftTestIfFactory >& handlerFactory) noexcept :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) override;

 protected:
  ::std::shared_ptr< ThriftTestIfFactory > handlerFactory_;
};

class ThriftTestMultiface : virtual public ThriftTestIf {
 public:
  ThriftTestMultiface(std::vector<std::shared_ptr<ThriftTestIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ThriftTestMultiface() {}
 protected:
  std::vector<std::shared_ptr<ThriftTestIf> > ifaces_;
  ThriftTestMultiface() {}
  void add(::std::shared_ptr<ThriftTestIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  /**
   * Prints "testVoid()" and returns nothing.
   */
  void testVoid() override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testVoid();
    }
    ifaces_[i]->testVoid();
  }

  /**
   * Prints 'testString("%s")' with thing as '%s'
   * @param string thing - the string to print
   * @return string - returns the string 'thing'
   * 
   * @param thing
   */
  void testString(std::string& _return, const std::string& thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testString(_return, thing);
    }
    ifaces_[i]->testString(_return, thing);
    return;
  }

  /**
   * Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
   * @param bool  thing - the bool data to print
   * @return bool  - returns the bool 'thing'
   * 
   * @param thing
   */
  bool testBool(const bool thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testBool(thing);
    }
    return ifaces_[i]->testBool(thing);
  }

  /**
   * Prints 'testByte("%d")' with thing as '%d'
   * The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
   * @param byte thing - the i8/byte to print
   * @return i8 - returns the i8/byte 'thing'
   * 
   * @param thing
   */
  int8_t testByte(const int8_t thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testByte(thing);
    }
    return ifaces_[i]->testByte(thing);
  }

  /**
   * Prints 'testI32("%d")' with thing as '%d'
   * @param i32 thing - the i32 to print
   * @return i32 - returns the i32 'thing'
   * 
   * @param thing
   */
  int32_t testI32(const int32_t thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testI32(thing);
    }
    return ifaces_[i]->testI32(thing);
  }

  /**
   * Prints 'testI64("%d")' with thing as '%d'
   * @param i64 thing - the i64 to print
   * @return i64 - returns the i64 'thing'
   * 
   * @param thing
   */
  int64_t testI64(const int64_t thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testI64(thing);
    }
    return ifaces_[i]->testI64(thing);
  }

  /**
   * Prints 'testDouble("%f")' with thing as '%f'
   * @param double thing - the double to print
   * @return double - returns the double 'thing'
   * 
   * @param thing
   */
  double testDouble(const double thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testDouble(thing);
    }
    return ifaces_[i]->testDouble(thing);
  }

  /**
   * Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
   * @param binary  thing - the binary data to print
   * @return binary  - returns the binary 'thing'
   * 
   * @param thing
   */
  void testBinary(std::string& _return, const std::string& thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testBinary(_return, thing);
    }
    ifaces_[i]->testBinary(_return, thing);
    return;
  }

  /**
   * Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
   * @param Xtruct thing - the Xtruct to print
   * @return Xtruct - returns the Xtruct 'thing'
   * 
   * @param thing
   */
  void testStruct(Xtruct& _return, const Xtruct& thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testStruct(_return, thing);
    }
    ifaces_[i]->testStruct(_return, thing);
    return;
  }

  /**
   * Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
   * @param Xtruct2 thing - the Xtruct2 to print
   * @return Xtruct2 - returns the Xtruct2 'thing'
   * 
   * @param thing
   */
  void testNest(Xtruct2& _return, const Xtruct2& thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testNest(_return, thing);
    }
    ifaces_[i]->testNest(_return, thing);
    return;
  }

  /**
   * Prints 'testMap("{%s")' where thing has been formatted into a string of 'key => value' pairs
   *  separated by commas and new lines
   * @param map<i32,i32> thing - the map<i32,i32> to print
   * @return map<i32,i32> - returns the map<i32,i32> 'thing'
   * 
   * @param thing
   */
  void testMap(std::map<int32_t, int32_t> & _return, const std::map<int32_t, int32_t> & thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testMap(_return, thing);
    }
    ifaces_[i]->testMap(_return, thing);
    return;
  }

  /**
   * Prints 'testStringMap("{%s}")' where thing has been formatted into a string of 'key => value' pairs
   *  separated by commas and new lines
   * @param map<string,string> thing - the map<string,string> to print
   * @return map<string,string> - returns the map<string,string> 'thing'
   * 
   * @param thing
   */
  void testStringMap(std::map<std::string, std::string> & _return, const std::map<std::string, std::string> & thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testStringMap(_return, thing);
    }
    ifaces_[i]->testStringMap(_return, thing);
    return;
  }

  /**
   * Prints 'testSet("{%s}")' where thing has been formatted into a string of values
   *  separated by commas and new lines
   * @param set<i32> thing - the set<i32> to print
   * @return set<i32> - returns the set<i32> 'thing'
   * 
   * @param thing
   */
  void testSet(std::set<int32_t> & _return, const std::set<int32_t> & thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testSet(_return, thing);
    }
    ifaces_[i]->testSet(_return, thing);
    return;
  }

  /**
   * Prints 'testList("{%s}")' where thing has been formatted into a string of values
   *  separated by commas and new lines
   * @param list<i32> thing - the list<i32> to print
   * @return list<i32> - returns the list<i32> 'thing'
   * 
   * @param thing
   */
  void testList(std::vector<int32_t> & _return, const std::vector<int32_t> & thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testList(_return, thing);
    }
    ifaces_[i]->testList(_return, thing);
    return;
  }

  /**
   * Prints 'testEnum("%d")' where thing has been formatted into its numeric value
   * @param Numberz thing - the Numberz to print
   * @return Numberz - returns the Numberz 'thing'
   * 
   * @param thing
   */
  Numberz::type testEnum(const Numberz::type thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testEnum(thing);
    }
    return ifaces_[i]->testEnum(thing);
  }

  /**
   * Prints 'testTypedef("%d")' with thing as '%d'
   * @param UserId thing - the UserId to print
   * @return UserId - returns the UserId 'thing'
   * 
   * @param thing
   */
  UserId testTypedef(const UserId thing) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testTypedef(thing);
    }
    return ifaces_[i]->testTypedef(thing);
  }

  /**
   * Prints 'testMapMap("%d")' with hello as '%d'
   * @param i32 hello - the i32 to print
   * @return map<i32,map<i32,i32>> - returns a dictionary with these values:
   *   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
   * 
   * @param hello
   */
  void testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t hello) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testMapMap(_return, hello);
    }
    ifaces_[i]->testMapMap(_return, hello);
    return;
  }

  /**
   * So you think you've got this all worked out, eh?
   * 
   * Creates a map with these values and prints it out:
   *   { 1 => { 2 => argument,
   *            3 => argument,
   *          },
   *     2 => { 6 => <empty Insanity struct>, },
   *   }
   * @return map<UserId, map<Numberz,Insanity>> - a map with the above values
   * 
   * @param argument
   */
  void testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const Insanity& argument) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testInsanity(_return, argument);
    }
    ifaces_[i]->testInsanity(_return, argument);
    return;
  }

  /**
   * Prints 'testMulti()'
   * @param i8 arg0 -
   * @param i32 arg1 -
   * @param i64 arg2 -
   * @param map<i16, string> arg3 -
   * @param Numberz arg4 -
   * @param UserId arg5 -
   * @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
   *    and i64_thing = arg2
   * 
   * @param arg0
   * @param arg1
   * @param arg2
   * @param arg3
   * @param arg4
   * @param arg5
   */
  void testMulti(Xtruct& _return, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testMulti(_return, arg0, arg1, arg2, arg3, arg4, arg5);
    }
    ifaces_[i]->testMulti(_return, arg0, arg1, arg2, arg3, arg4, arg5);
    return;
  }

  /**
   * Print 'testException(%s)' with arg as '%s'
   * @param string arg - a string indication what type of exception to throw
   * if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
   * else if arg == "TException" throw TException
   * else do not throw anything
   * 
   * @param arg
   */
  void testException(const std::string& arg) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testException(arg);
    }
    ifaces_[i]->testException(arg);
  }

  /**
   * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
   * @param string arg - a string indicating what type of exception to throw
   * if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
   * else if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
   * else do not throw anything
   * @return Xtruct - an Xtruct with string_thing = arg1
   * 
   * @param arg0
   * @param arg1
   */
  void testMultiException(Xtruct& _return, const std::string& arg0, const std::string& arg1) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testMultiException(_return, arg0, arg1);
    }
    ifaces_[i]->testMultiException(_return, arg0, arg1);
    return;
  }

  /**
   * Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
   * sleep 'secondsToSleep'
   * Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
   * @param i32 secondsToSleep - the number of seconds to sleep
   * 
   * @param secondsToSleep
   */
  void testOneway(const int32_t secondsToSleep) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->testOneway(secondsToSleep);
    }
    ifaces_[i]->testOneway(secondsToSleep);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class ThriftTestConcurrentClient : virtual public ThriftTestIf {
 public:
  ThriftTestConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  ThriftTestConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  /**
   * Prints "testVoid()" and returns nothing.
   */
  void testVoid() override;
  int32_t send_testVoid();
  void recv_testVoid(const int32_t seqid);
  /**
   * Prints 'testString("%s")' with thing as '%s'
   * @param string thing - the string to print
   * @return string - returns the string 'thing'
   * 
   * @param thing
   */
  void testString(std::string& _return, const std::string& thing) override;
  int32_t send_testString(const std::string& thing);
  void recv_testString(std::string& _return, const int32_t seqid);
  /**
   * Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
   * @param bool  thing - the bool data to print
   * @return bool  - returns the bool 'thing'
   * 
   * @param thing
   */
  bool testBool(const bool thing) override;
  int32_t send_testBool(const bool thing);
  bool recv_testBool(const int32_t seqid);
  /**
   * Prints 'testByte("%d")' with thing as '%d'
   * The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
   * @param byte thing - the i8/byte to print
   * @return i8 - returns the i8/byte 'thing'
   * 
   * @param thing
   */
  int8_t testByte(const int8_t thing) override;
  int32_t send_testByte(const int8_t thing);
  int8_t recv_testByte(const int32_t seqid);
  /**
   * Prints 'testI32("%d")' with thing as '%d'
   * @param i32 thing - the i32 to print
   * @return i32 - returns the i32 'thing'
   * 
   * @param thing
   */
  int32_t testI32(const int32_t thing) override;
  int32_t send_testI32(const int32_t thing);
  int32_t recv_testI32(const int32_t seqid);
  /**
   * Prints 'testI64("%d")' with thing as '%d'
   * @param i64 thing - the i64 to print
   * @return i64 - returns the i64 'thing'
   * 
   * @param thing
   */
  int64_t testI64(const int64_t thing) override;
  int32_t send_testI64(const int64_t thing);
  int64_t recv_testI64(const int32_t seqid);
  /**
   * Prints 'testDouble("%f")' with thing as '%f'
   * @param double thing - the double to print
   * @return double - returns the double 'thing'
   * 
   * @param thing
   */
  double testDouble(const double thing) override;
  int32_t send_testDouble(const double thing);
  double recv_testDouble(const int32_t seqid);
  /**
   * Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
   * @param binary  thing - the binary data to print
   * @return binary  - returns the binary 'thing'
   * 
   * @param thing
   */
  void testBinary(std::string& _return, const std::string& thing) override;
  int32_t send_testBinary(const std::string& thing);
  void recv_testBinary(std::string& _return, const int32_t seqid);
  /**
   * Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
   * @param Xtruct thing - the Xtruct to print
   * @return Xtruct - returns the Xtruct 'thing'
   * 
   * @param thing
   */
  void testStruct(Xtruct& _return, const Xtruct& thing) override;
  int32_t send_testStruct(const Xtruct& thing);
  void recv_testStruct(Xtruct& _return, const int32_t seqid);
  /**
   * Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
   * @param Xtruct2 thing - the Xtruct2 to print
   * @return Xtruct2 - returns the Xtruct2 'thing'
   * 
   * @param thing
   */
  void testNest(Xtruct2& _return, const Xtruct2& thing) override;
  int32_t send_testNest(const Xtruct2& thing);
  void recv_testNest(Xtruct2& _return, const int32_t seqid);
  /**
   * Prints 'testMap("{%s")' where thing has been formatted into a string of 'key => value' pairs
   *  separated by commas and new lines
   * @param map<i32,i32> thing - the map<i32,i32> to print
   * @return map<i32,i32> - returns the map<i32,i32> 'thing'
   * 
   * @param thing
   */
  void testMap(std::map<int32_t, int32_t> & _return, const std::map<int32_t, int32_t> & thing) override;
  int32_t send_testMap(const std::map<int32_t, int32_t> & thing);
  void recv_testMap(std::map<int32_t, int32_t> & _return, const int32_t seqid);
  /**
   * Prints 'testStringMap("{%s}")' where thing has been formatted into a string of 'key => value' pairs
   *  separated by commas and new lines
   * @param map<string,string> thing - the map<string,string> to print
   * @return map<string,string> - returns the map<string,string> 'thing'
   * 
   * @param thing
   */
  void testStringMap(std::map<std::string, std::string> & _return, const std::map<std::string, std::string> & thing) override;
  int32_t send_testStringMap(const std::map<std::string, std::string> & thing);
  void recv_testStringMap(std::map<std::string, std::string> & _return, const int32_t seqid);
  /**
   * Prints 'testSet("{%s}")' where thing has been formatted into a string of values
   *  separated by commas and new lines
   * @param set<i32> thing - the set<i32> to print
   * @return set<i32> - returns the set<i32> 'thing'
   * 
   * @param thing
   */
  void testSet(std::set<int32_t> & _return, const std::set<int32_t> & thing) override;
  int32_t send_testSet(const std::set<int32_t> & thing);
  void recv_testSet(std::set<int32_t> & _return, const int32_t seqid);
  /**
   * Prints 'testList("{%s}")' where thing has been formatted into a string of values
   *  separated by commas and new lines
   * @param list<i32> thing - the list<i32> to print
   * @return list<i32> - returns the list<i32> 'thing'
   * 
   * @param thing
   */
  void testList(std::vector<int32_t> & _return, const std::vector<int32_t> & thing) override;
  int32_t send_testList(const std::vector<int32_t> & thing);
  void recv_testList(std::vector<int32_t> & _return, const int32_t seqid);
  /**
   * Prints 'testEnum("%d")' where thing has been formatted into its numeric value
   * @param Numberz thing - the Numberz to print
   * @return Numberz - returns the Numberz 'thing'
   * 
   * @param thing
   */
  Numberz::type testEnum(const Numberz::type thing) override;
  int32_t send_testEnum(const Numberz::type thing);
  Numberz::type recv_testEnum(const int32_t seqid);
  /**
   * Prints 'testTypedef("%d")' with thing as '%d'
   * @param UserId thing - the UserId to print
   * @return UserId - returns the UserId 'thing'
   * 
   * @param thing
   */
  UserId testTypedef(const UserId thing) override;
  int32_t send_testTypedef(const UserId thing);
  UserId recv_testTypedef(const int32_t seqid);
  /**
   * Prints 'testMapMap("%d")' with hello as '%d'
   * @param i32 hello - the i32 to print
   * @return map<i32,map<i32,i32>> - returns a dictionary with these values:
   *   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
   * 
   * @param hello
   */
  void testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t hello) override;
  int32_t send_testMapMap(const int32_t hello);
  void recv_testMapMap(std::map<int32_t, std::map<int32_t, int32_t> > & _return, const int32_t seqid);
  /**
   * So you think you've got this all worked out, eh?
   * 
   * Creates a map with these values and prints it out:
   *   { 1 => { 2 => argument,
   *            3 => argument,
   *          },
   *     2 => { 6 => <empty Insanity struct>, },
   *   }
   * @return map<UserId, map<Numberz,Insanity>> - a map with the above values
   * 
   * @param argument
   */
  void testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const Insanity& argument) override;
  int32_t send_testInsanity(const Insanity& argument);
  void recv_testInsanity(std::map<UserId, std::map<Numberz::type, Insanity> > & _return, const int32_t seqid);
  /**
   * Prints 'testMulti()'
   * @param i8 arg0 -
   * @param i32 arg1 -
   * @param i64 arg2 -
   * @param map<i16, string> arg3 -
   * @param Numberz arg4 -
   * @param UserId arg5 -
   * @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
   *    and i64_thing = arg2
   * 
   * @param arg0
   * @param arg1
   * @param arg2
   * @param arg3
   * @param arg4
   * @param arg5
   */
  void testMulti(Xtruct& _return, const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5) override;
  int32_t send_testMulti(const int8_t arg0, const int32_t arg1, const int64_t arg2, const std::map<int16_t, std::string> & arg3, const Numberz::type arg4, const UserId arg5);
  void recv_testMulti(Xtruct& _return, const int32_t seqid);
  /**
   * Print 'testException(%s)' with arg as '%s'
   * @param string arg - a string indication what type of exception to throw
   * if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
   * else if arg == "TException" throw TException
   * else do not throw anything
   * 
   * @param arg
   */
  void testException(const std::string& arg) override;
  int32_t send_testException(const std::string& arg);
  void recv_testException(const int32_t seqid);
  /**
   * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
   * @param string arg - a string indicating what type of exception to throw
   * if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
   * else if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
   * else do not throw anything
   * @return Xtruct - an Xtruct with string_thing = arg1
   * 
   * @param arg0
   * @param arg1
   */
  void testMultiException(Xtruct& _return, const std::string& arg0, const std::string& arg1) override;
  int32_t send_testMultiException(const std::string& arg0, const std::string& arg1);
  void recv_testMultiException(Xtruct& _return, const int32_t seqid);
  /**
   * Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
   * sleep 'secondsToSleep'
   * Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
   * @param i32 secondsToSleep - the number of seconds to sleep
   * 
   * @param secondsToSleep
   */
  void testOneway(const int32_t secondsToSleep) override;
  void send_testOneway(const int32_t secondsToSleep);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

}} // namespace

#endif
